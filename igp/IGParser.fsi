// Signature file for parser generated by fsyacc
module IGParser
type token = 
  | EOF
  | F_LP
  | M_LP
  | P_LP
  | P_LC
  | E_LP
  | E_LC
  | I_LP
  | D_LP
  | Bind_LP
  | Bind_LC
  | Bdir_LP
  | Bdir_LC
  | Cex_LP
  | Cex_LC
  | Cac_LP
  | Cac_LC
  | A_LP
  | A_LC
  | DESCRIPTOR of (string)
  | WS of (string)
  | AND
  | OR
  | XOR
  | NOT
  | SEP
  | LP
  | RP
  | LB
  | RB
  | LC
  | RC
type tokenId = 
    | TOKEN_EOF
    | TOKEN_F_LP
    | TOKEN_M_LP
    | TOKEN_P_LP
    | TOKEN_P_LC
    | TOKEN_E_LP
    | TOKEN_E_LC
    | TOKEN_I_LP
    | TOKEN_D_LP
    | TOKEN_Bind_LP
    | TOKEN_Bind_LC
    | TOKEN_Bdir_LP
    | TOKEN_Bdir_LC
    | TOKEN_Cex_LP
    | TOKEN_Cex_LC
    | TOKEN_Cac_LP
    | TOKEN_Cac_LC
    | TOKEN_A_LP
    | TOKEN_A_LC
    | TOKEN_DESCRIPTOR
    | TOKEN_WS
    | TOKEN_AND
    | TOKEN_OR
    | TOKEN_XOR
    | TOKEN_NOT
    | TOKEN_SEP
    | TOKEN_LP
    | TOKEN_RP
    | TOKEN_LB
    | TOKEN_RB
    | TOKEN_LC
    | TOKEN_RC
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start
    | NONTERM_descriptor
    | NONTERM_signeddescriptor
    | NONTERM_nestedstatement
    | NONTERM_simpledescriptors
    | NONTERM_complexdescriptors
    | NONTERM_contextcategory
    | NONTERM_actconditiontype
    | NONTERM_actconditiontypes
    | NONTERM_conditions
    | NONTERM_execconstrainttype
    | NONTERM_execconstrainttypes
    | NONTERM_constraints
    | NONTERM_context
    | NONTERM_attributes
    | NONTERM_directobjects
    | NONTERM_objectdir
    | NONTERM_indirectobjects
    | NONTERM_objectind
    | NONTERM_object
    | NONTERM_deontic
    | NONTERM_aim
    | NONTERM_entity
    | NONTERM_propertycombos
    | NONTERM_properties
    | NONTERM_modal
    | NONTERM_function
    | NONTERM_aic
    | NONTERM_abdic
    | NONTERM_fec
    | NONTERM_pmfec
    | NONTERM_complexstatement
    | NONTERM_statement
    | NONTERM_and_or_xor
    | NONTERM_optional_not
    | NONTERM_c_a_f
    | NONTERM_optional_bracketed_c_a_f
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start : (FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> FSharp.Text.Lexing.LexBuffer<'cty> -> ( int ) 
